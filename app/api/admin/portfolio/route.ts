import { NextResponse } from 'next/server';
import { auth, clerkClient } from '@clerk/nextjs/server';
import prisma, { executeWithRetry } from '@/lib/prisma';
import { z } from 'zod';
import { checkAdminAuth } from "@/lib/check-admin";

// Schema de valida√ß√£o para cria√ß√£o de item do portf√≥lio
const createPortfolioSchema = z.object({
  title: z.string().min(1, 'T√≠tulo √© obrigat√≥rio').max(255, 'T√≠tulo muito longo'),
  description: z.string().optional().nullable(),
  detailedDescription: z.string().optional().nullable(),
  category: z.enum(['WEDDING_RINGS', 'REPAIRS_BEFORE_AFTER', 'GOLD_PLATING', 'CUSTOM_JEWELRY', 'GRADUATION_RINGS'], {
    errorMap: () => ({ message: 'Categoria inv√°lida' })
  }),
  customCategory: z.string().optional().nullable(),
  mainImage: z.string().min(1, 'Imagem principal √© obrigat√≥ria').refine((val) => {
    // Accept both URLs and base64 images
    return val.startsWith('http') || val.startsWith('data:image') || val.length > 0;
  }, 'Formato de imagem inv√°lido'),
  images: z.union([z.array(z.string()), z.string()]).transform((val) => {
    if (typeof val === 'string') {
      try {
        return JSON.parse(val);
      } catch {
        return [];
      }
    }
    return val || [];
  }),
  isActive: z.union([z.boolean(), z.string()]).transform((val) => {
    if (typeof val === 'string') {
      return val === 'true' || val === '1';
    }
    return val !== false;
  }).default(true),
  status: z.string().regex(/^(DRAFT|PUBLISHED|FEATURED)$/, 'Status inv√°lido').default('DRAFT'),
  order: z.union([z.number(), z.string()]).transform((val) => {
    if (typeof val === 'string') {
      const parsed = parseInt(val, 10);
      return isNaN(parsed) ? 0 : parsed;
    }
    return val || 0;
  }).refine((val) => val >= 0, 'Ordem n√£o pode ser negativa'),
  specifications: z.union([z.record(z.string()), z.string()]).transform((val) => {
    if (typeof val === 'string') {
      try {
        return JSON.parse(val);
      } catch {
        return null;
      }
    }
    return val;
  }).optional().nullable(),
  seoTitle: z.string().optional().nullable().refine((val) => !val || val.length <= 60, {
    message: 'T√≠tulo SEO deve ter no m√°ximo 60 caracteres'
  }),
  seoDescription: z.string().optional().nullable().refine((val) => !val || val.length <= 160, {
    message: 'Descri√ß√£o SEO deve ter no m√°ximo 160 caracteres'
  }),
  keywords: z.union([z.array(z.string()), z.string()]).transform((val) => {
    if (typeof val === 'string') {
      try {
        return JSON.parse(val);
      } catch {
        return [];
      }
    }
    return val || [];
  }),
  relatedProjects: z.union([z.array(z.string()), z.string()]).transform((val) => {
    if (typeof val === 'string') {
      try {
        return JSON.parse(val);
      } catch {
        return [];
      }
    }
    return val || [];
  }),
  productId: z.string().optional().nullable(),
});

// GET /api/admin/portfolio - Listar itens do portf√≥lio
export async function GET() {
  const requestId = Math.random().toString(36).substring(7);
  const startTime = Date.now();
  const debugInfo: string[] = [];

  try {
    debugInfo.push(`üîÑ [${requestId}] Portfolio GET: Starting request processing at ${new Date().toISOString()}`);
    console.log(debugInfo[debugInfo.length - 1]);

    // Etapa 1: Teste de autentica√ß√£o com timing
    const authStart = Date.now();
    let authResult;

    try {
      authResult = await checkAdminAuth();
      const authDuration = Date.now() - authStart;
      debugInfo.push(`‚úÖ [${requestId}] Auth completed in ${authDuration}ms`);
      console.log(debugInfo[debugInfo.length - 1]);
    } catch (authError) {
      const authDuration = Date.now() - authStart;
      debugInfo.push(`‚ùå [${requestId}] Auth threw exception after ${authDuration}ms: ${authError instanceof Error ? authError.message : String(authError)}`);
      console.error(debugInfo[debugInfo.length - 1]);
      throw authError;
    }

    if ("error" in authResult) {
      debugInfo.push(`‚ùå [${requestId}] Auth failed: ${authResult.error} (status: ${authResult.status})`);
      console.error(debugInfo[debugInfo.length - 1]);
      return NextResponse.json(
        { error: authResult.error, debug: debugInfo },
        {
          status: authResult.status,
          headers: { 'X-Debug-Info': JSON.stringify(debugInfo), 'X-Request-ID': requestId }
        }
      );
    }

    const { userId } = authResult;
    debugInfo.push(`‚úÖ [${requestId}] Auth successful for userId: ${userId}`);
    console.log(debugInfo[debugInfo.length - 1]);

    // Etapa 2: Teste de conex√£o com banco
    const dbConnectStart = Date.now();
    try {
      await prisma.$connect();
      const dbConnectDuration = Date.now() - dbConnectStart;
      debugInfo.push(`üîó [${requestId}] Database connection successful in ${dbConnectDuration}ms`);
      console.log(debugInfo[debugInfo.length - 1]);
    } catch (dbConnectError) {
      const dbConnectDuration = Date.now() - dbConnectStart;
      debugInfo.push(`üíæ [${requestId}] Database connection failed after ${dbConnectDuration}ms: ${dbConnectError instanceof Error ? dbConnectError.message : String(dbConnectError)}`);
      console.error(debugInfo[debugInfo.length - 1]);
      throw dbConnectError;
    }

    // Etapa 3: Teste de query simples primeiro
    const simpleQueryStart = Date.now();
    try {
      await prisma.$queryRaw`SELECT 1 as test`;
      const simpleQueryDuration = Date.now() - simpleQueryStart;
      debugInfo.push(`‚úÖ [${requestId}] Simple query test successful in ${simpleQueryDuration}ms`);
      console.log(debugInfo[debugInfo.length - 1]);
    } catch (simpleQueryError) {
      const simpleQueryDuration = Date.now() - simpleQueryStart;
      debugInfo.push(`‚ùå [${requestId}] Simple query failed after ${simpleQueryDuration}ms: ${simpleQueryError instanceof Error ? simpleQueryError.message : String(simpleQueryError)}`);
      console.error(debugInfo[debugInfo.length - 1]);
      throw simpleQueryError;
    }

    // Etapa 4: Teste de contagem da tabela
    const countStart = Date.now();
    let itemCount;
    try {
      itemCount = await prisma.portfolioItem.count();
      const countDuration = Date.now() - countStart;
      debugInfo.push(`üìä [${requestId}] Portfolio count query successful in ${countDuration}ms: ${itemCount} items`);
      console.log(debugInfo[debugInfo.length - 1]);
    } catch (countError) {
      const countDuration = Date.now() - countStart;
      debugInfo.push(`‚ùå [${requestId}] Portfolio count failed after ${countDuration}ms: ${countError instanceof Error ? countError.message : String(countError)}`);
      console.error(debugInfo[debugInfo.length - 1]);
      throw countError;
    }

    // Etapa 5: Query completa com executeWithRetry
    const fullQueryStart = Date.now();
    let portfolioItems;
    try {
      debugInfo.push(`üìä [${requestId}] Starting full portfolio query with executeWithRetry...`);
      console.log(debugInfo[debugInfo.length - 1]);

      portfolioItems = await executeWithRetry(async () => {
        debugInfo.push(`üîÑ [${requestId}] Executing portfolio findMany inside retry...`);
        console.log(debugInfo[debugInfo.length - 1]);

        return await prisma.portfolioItem.findMany({
          include: {
            product: {
              select: {
                id: true,
                name: true,
              },
            },
          },
          orderBy: [
            { order: 'asc' },
            { createdAt: 'desc' },
          ],
        });
      });

      const fullQueryDuration = Date.now() - fullQueryStart;
      debugInfo.push(`‚úÖ [${requestId}] Full portfolio query successful in ${fullQueryDuration}ms: Found ${portfolioItems.length} items`);
      console.log(debugInfo[debugInfo.length - 1]);
    } catch (fullQueryError) {
      const fullQueryDuration = Date.now() - fullQueryStart;
      debugInfo.push(`‚ùå [${requestId}] Full portfolio query failed after ${fullQueryDuration}ms: ${fullQueryError instanceof Error ? fullQueryError.message : String(fullQueryError)}`);
      console.error(debugInfo[debugInfo.length - 1]);

      // Log stack trace completo para debugging
      if (fullQueryError instanceof Error && fullQueryError.stack) {
        console.error(`üîç [${requestId}] Full error stack:`, fullQueryError.stack);
        debugInfo.push(`üîç [${requestId}] Error stack: ${fullQueryError.stack.substring(0, 500)}...`);
      }

      throw fullQueryError;
    }

    const totalDuration = Date.now() - startTime;
    debugInfo.push(`üéâ [${requestId}] Request completed successfully in ${totalDuration}ms`);
    console.log(debugInfo[debugInfo.length - 1]);

    return NextResponse.json(
      { portfolioItems, debug: debugInfo },
      {
        headers: {
          'X-Debug-Info': JSON.stringify(debugInfo),
          'X-Request-ID': requestId,
          'X-Total-Duration': `${totalDuration}ms`,
          'X-Items-Count': portfolioItems.length.toString()
        }
      }
    );

  } catch (error) {
    const totalDuration = Date.now() - startTime;
    const errorInfo = {
      message: error instanceof Error ? error.message : String(error),
      name: error instanceof Error ? error.name : 'Unknown',
      stack: error instanceof Error ? error.stack : undefined,
      type: typeof error,
      requestId,
      duration: totalDuration,
      timestamp: new Date().toISOString(),
    };

    debugInfo.push(`üí• [${requestId}] Request failed after ${totalDuration}ms: ${errorInfo.message}`);
    console.error(debugInfo[debugInfo.length - 1]);
    console.error(`üí• [${requestId}] Complete error details:`, errorInfo);

    // Categorizar erro por tipo
    let statusCode = 500;
    let userMessage = 'Erro interno do servidor';

    if (error instanceof Error) {
      if (error.message.includes('connect') || error.message.includes('ECONNREFUSED')) {
        statusCode = 503;
        userMessage = 'Erro de conex√£o com o banco de dados';
        debugInfo.push(`üíæ [${requestId}] Categorized as database connection error`);
      } else if (error.message.includes('timeout')) {
        statusCode = 504;
        userMessage = 'Timeout na opera√ß√£o';
        debugInfo.push(`‚è∞ [${requestId}] Categorized as timeout error`);
      } else if (error.message.includes('prepared statement')) {
        statusCode = 503;
        userMessage = 'Erro tempor√°rio do servidor - tente novamente';
        debugInfo.push(`üîÑ [${requestId}] Categorized as prepared statement error`);
      } else if (error.message.includes('N√£o autorizado') || error.message.includes('Acesso negado')) {
        statusCode = error.message.includes('N√£o autorizado') ? 401 : 403;
        userMessage = error.message;
        debugInfo.push(`üö´ [${requestId}] Categorized as auth error`);
      }
    }

    console.error(`üîç [${requestId}] Final error categorization: ${statusCode} - ${userMessage}`);

    return NextResponse.json(
      {
        error: userMessage,
        debug: debugInfo,
        errorDetails: process.env.NODE_ENV === 'development' ? errorInfo : undefined,
        requestId
      },
      {
        status: statusCode,
        headers: {
          'X-Debug-Info': JSON.stringify(debugInfo),
          'X-Request-ID': requestId,
          'X-Error-Type': errorInfo.name,
          'X-Total-Duration': `${totalDuration}ms`
        }
      }
    );
  }
}

// POST /api/admin/portfolio - Criar item do portf√≥lio
export async function POST(request: Request) {
  const debugInfo: string[] = [];
  const startTime = Date.now();

  try {
    debugInfo.push(`POST started at ${new Date().toISOString()}`);

    // Teste 1: Parse do request body
    let body: any;
    try {
      body = await request.json();
      debugInfo.push(`Request body parsed successfully - keys: ${Object.keys(body).join(', ')}`);
    } catch (bodyError) {
      debugInfo.push(`Request body parse failed: ${bodyError instanceof Error ? bodyError.message : String(bodyError)}`);
      return NextResponse.json(
        { error: 'Dados inv√°lidos no corpo da requisi√ß√£o', debug: debugInfo },
        {
          status: 400,
          headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
        }
      );
    }

    // Teste 2: Autentica√ß√£o
    const authResult = await checkAdminAuth();
    if ("error" in authResult) {
      debugInfo.push(`Auth failed: ${authResult.error}`);
      return NextResponse.json(
        { error: authResult.error, debug: debugInfo },
        {
          status: authResult.status,
          headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
        }
      );
    }
    const { userId } = authResult;
    debugInfo.push(`Auth successful for user: ${userId}`);

    // Teste 3: Valida√ß√£o dos dados
    let validatedData;
    try {
      validatedData = createPortfolioSchema.parse(body);
      debugInfo.push(`Data validation successful - title: "${validatedData.title}", category: ${validatedData.category}`);
    } catch (validationError) {
      if (validationError instanceof z.ZodError) {
        const validationDetails = validationError.errors.map(e => ({
          field: e.path.join('.'),
          message: e.message,
          received: 'received' in e ? e.received : undefined,
          code: e.code
        }));

        debugInfo.push(`Validation failed on fields: ${validationDetails.map(d => `${d.field} (${d.message})`).join(', ')}`);

        return NextResponse.json(
          {
            error: 'Dados inv√°lidos para cria√ß√£o',
            details: validationDetails,
            debug: debugInfo,
            receivedData: Object.keys(body).reduce((acc, key) => {
              acc[key] = typeof body[key] === 'string' && body[key].length > 100
                ? `${body[key].substring(0, 100)}... (${body[key].length} chars)`
                : body[key];
              return acc;
            }, {} as any)
          },
          {
            status: 400,
            headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
          }
        );
      }
      debugInfo.push(`Unexpected validation error: ${validationError instanceof Error ? validationError.message : String(validationError)}`);
      return NextResponse.json(
        { error: 'Erro de valida√ß√£o', debug: debugInfo },
        {
          status: 400,
          headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
        }
      );
    }

    // Teste 4: Preparar dados para o Prisma
    type CreatePortfolioData = z.infer<typeof createPortfolioSchema>;
    let createData: CreatePortfolioData;
    try {
      createData = {
        ...validatedData,
        ...(validatedData.specifications !== undefined && {
          specifications: validatedData.specifications as any,
        }),
      };
      debugInfo.push('Data preparation for Prisma successful');
    } catch (prepError) {
      debugInfo.push(`Data preparation failed: ${prepError instanceof Error ? prepError.message : String(prepError)}`);
      return NextResponse.json(
        { error: 'Erro na prepara√ß√£o dos dados', debug: debugInfo },
        {
          status: 500,
          headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
        }
      );
    }

    // Teste 5: Conex√£o com banco
    try {
      await prisma.$connect();
      debugInfo.push('Database connection successful');
    } catch (dbConnectError) {
      debugInfo.push(`Database connection failed: ${dbConnectError instanceof Error ? dbConnectError.message : String(dbConnectError)}`);
      return NextResponse.json(
        { error: 'Erro de conex√£o com banco de dados', debug: debugInfo },
        {
          status: 500,
          headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
        }
      );
    }

    // Teste 6: Criar item do portf√≥lio (com retry otimizado para prepared statement errors)
    let portfolioItem: any;
    try {
      portfolioItem = await executeWithRetry(async () => {
        return await prisma.portfolioItem.create({
          data: createData,
          include: {
            product: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        });
      });
      debugInfo.push(`Portfolio item created successfully with ID: ${portfolioItem.id}`);
    } catch (createError) {
      const errorMessage = createError instanceof Error ? createError.message : String(createError);
      debugInfo.push(`Creation failed: ${errorMessage}`);

      // Verificar tipos espec√≠ficos de erro
      if (errorMessage.includes('Unique constraint')) {
        return NextResponse.json(
          { error: 'J√° existe um item com essas informa√ß√µes', debug: debugInfo },
          {
            status: 409,
            headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
          }
        );
      }

      if (errorMessage.includes('Foreign key constraint')) {
        return NextResponse.json(
          { error: 'Produto relacionado n√£o encontrado', debug: debugInfo },
          {
            status: 400,
            headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
          }
        );
      }

      if (errorMessage.includes('prepared statement') && errorMessage.includes('already exists')) {
        return NextResponse.json(
          { error: 'Erro tempor√°rio do servidor. Tente novamente em alguns segundos.', debug: debugInfo },
          {
            status: 503,
            headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
          }
        );
      }

      return NextResponse.json(
        { error: 'Erro ao criar item do portf√≥lio', debug: debugInfo },
        {
          status: 500,
          headers: { 'X-Debug-Info': JSON.stringify(debugInfo) }
        }
      );
    }

    // Teste 7: Log da atividade
    try {
      await executeWithRetry(async () => {
        return await prisma.activityLog.create({
          data: {
            action: 'CREATE',
            entity: 'PortfolioItem',
            entityId: portfolioItem.id,
            description: `Item "${portfolioItem.title}" criado no portf√≥lio`,
            userId,
          },
        });
      });
      debugInfo.push('Activity log created successfully');
    } catch (logError) {
      debugInfo.push(`Activity log failed: ${logError instanceof Error ? logError.message : String(logError)}`);
      // N√£o falhar a opera√ß√£o por causa do log
    }

    const endTime = Date.now();
    debugInfo.push(`Creation completed successfully in ${endTime - startTime}ms`);

    return NextResponse.json(
      { portfolioItem, debug: debugInfo },
      {
        status: 201,
        headers: {
          'X-Debug-Info': JSON.stringify(debugInfo),
          'X-Operation-Time': `${endTime - startTime}ms`
        }
      }
    );

  } catch (error) {
    const endTime = Date.now();
    debugInfo.push(`Unexpected error after ${endTime - startTime}ms: ${error instanceof Error ? error.message : String(error)}`);

    return NextResponse.json(
      {
        error: 'Erro interno do servidor',
        debug: debugInfo,
        details: error instanceof Error ? {
          message: error.message,
          name: error.name
        } : String(error)
      },
      {
        status: 500,
        headers: {
          'X-Debug-Info': JSON.stringify(debugInfo),
          'X-Operation-Time': `${endTime - startTime}ms`
        }
      }
    );
  }
}

export const config = {
  api: {
    bodyParser: {
      sizeLimit: '50mb', // Increased for large base64 images
    },
  },
}; 